using System;
using System.Reflection;
using System.Linq.Expressions;
using System.Collections.Generic;
using System.Linq;
using SF.Metadata;
using System.Reflection.Emit;
using SF.Core.ServiceManagement;
using System.ComponentModel.DataAnnotations.Schema;
using SF.Data;
using System.ComponentModel.DataAnnotations;
using System.Linq.TypeExpressions;

namespace SF.Entities.AutoEntityProvider.Internals.DataModelBuilders
{

	public class BaseDataModel
	{

	}
	
	public class DataModelTypeCollection : Dictionary<string, Type>, IDataModelTypeCollection
	{

	}

	public class DataModelBuilder : IDataModelBuildContext
	{

		IDynamicTypeBuilder DynamicTypeBuilder { get; }

		public Dictionary<string, TypeExpression> TypeExpressions { get; } = new Dictionary<string, TypeExpression>();

		public IMetadataCollection Metadata { get; }
		
		IDataModelBuildProvider[] DataModelBuildProviders { get; }
		NamedServiceResolver<IDataModelAttributeGenerator> DataModelAttributeGeneratorResolver { get; }
		public DataModelBuilder(
			IMetadataCollection Metadata,
			IDynamicTypeBuilder DynamicTypeBuilder,
			IEnumerable<IDataModelBuildProvider> DataModelBuildProviders,
			NamedServiceResolver<IDataModelAttributeGenerator> DataModelAttributeGeneratorResolver
			)
		{
			this.DynamicTypeBuilder = DynamicTypeBuilder;
			this.Metadata = Metadata;
			this.DataModelBuildProviders = DataModelBuildProviders.OrderBy(p=>p.Priority).ToArray();
			this.DataModelAttributeGeneratorResolver = DataModelAttributeGeneratorResolver;
		}
		
		static volatile int TypeIdSeed = 1;
		static int NextTypeId()
		{
			return System.Threading.Interlocked.Increment(ref TypeIdSeed);
		}

		public IDataModelTypeCollection Build(string Prefix)
		{
			//throw new ArgumentException(metas.ToString());
			foreach (var et in Metadata.EntityTypes.Where(et=>et.Value.AutoGenerateDataModel))
			{
				var type = new TypeExpression(
					et.Key + "_" + NextTypeId(),
					new SystemTypeReference(typeof(BaseDataModel)),
					TypeAttributes.Public
					);

				foreach (var a in et.Value.Attributes)
				{
					var g = DataModelAttributeGeneratorResolver(a.Name);
					if (g == null)
						continue;
						//throw new ArgumentException($"不支持生成特性{a.Name}的数据类特性，实体类型:{typeExpr.Name}");
					var aa = g.Generate(a);
					if (aa != null)
						type.CustomAttributes.Add(aa);
				}
				TypeExpressions.Add(et.Key, type);

			}

			foreach (var p in DataModelBuildProviders)
				p.BeforeBuildModel(this);

			foreach (var p in DataModelBuildProviders.Reverse())
				p.AfterBuildModel(this);

			var exprs = (from entityType in Metadata.EntityTypes.Values
						 where entityType.AutoGenerateDataModel
						 let typeExpr = TypeExpressions.Get(entityType.FullName)
						 where typeExpr!=null
						 select (entityType.FullName, typeExpr)
						).ToArray();

			var re = new DataModelTypeCollection();
			var types = DynamicTypeBuilder.Build(exprs.Select(e => e.typeExpr));
			exprs
				.Zip(types, (x, type) => (x.FullName,type))
				.ForEach(p=>re.Add(p.FullName, p.type));
			return re;
		}
	}
}
